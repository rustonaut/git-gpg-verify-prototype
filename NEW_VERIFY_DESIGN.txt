V


- uses: rustonaut/gpg-git-verify
  with:
    verify_pr_commits_and_tags: true
    allow_unsigned_commits: true
    allow_unsigned_tags: false
    required_commit_trust_level: Unknown
    required_tag_trust_level: full

--------

- uses: actions/checkout@v1
- id: cargo-lookup-versions
  uses: rustonaut/cargo-version-lookup@v1
  with:
    with_prefix: "v"
- id: verifyed-tags
  uses: rustonaut/gpg-git-verify@v1
  with:
    verify_all_tags: true
    filter_tags: v_semver
    exclude_tags: ${{ steps.cargo-lookup-versions.outputs.versions }}
    allow_unsigned_tags: false
    require_tag_trust_level: full
- uses: rustonaut/cargo-publish-by-tags@v1
  with:
    tags: ${{ steps.verified-tags.output.verified-tags }}
    cargo-token: ${{ secrets.CARGO_TOKEN }}

----

const options =  parseOptions()
const errors = []
const commits = Set()
const tags = Set()

if (options.commit_range) {
    commits.addAll(await lookUpCommitRange(options.commit_range))
}

if (option.last_commit) {
    commits.add(await lookUpLastCommit())
}

if (options.lookUpAllTags) {
    tags.addAll(await lookUpAllTags) //git tag --list
} else if (options.lookUpTagsForCommits) {
    for(const commit in commits) {
        const tag = await lookupTagForCommit(commit)
        if (tag) {
            tags.add(tag)
        }
    }
}


errors.pushAll(await verifyCommits(commits))
errors.pushAll(await verifyTags(tags))

async function verifyCommits(commits) {
    return await verifyAny(gitVerifyCommit, commits)
}

async function verifyTags(tags) {
    return await verifyAny(gitVerifyTag, tags)
}

async function verifyAny(verify_fn, entities) {
    //TODO const errors = entities.map(verify_fn).filterMap(proccessResults);
    const errors = []
    for (const entitty in entities) {
        const verify_result = await verify_fn(entities)
        switch (verify_result.status) {
            case "no_signature": 
                if (!options.allow_unsigned_commits) {
                    errors.push(new SigningError(verify_result, "unsiged"))
                }
                break;
            case "bad_signature":
                errors.push(new SigningError(verify_result, "bad"))
                break;
            case "good_signature":
                const trust_level = verify_result.trust_level
                const error = checkTrustLevel(options.required_commit_trust_level, trust_level)
                if (error) {
                    errors.push(error)
                }
                break;
            default:
                errorTODO
                break;
        }
    }
    reutrn errors;
}

async function gpgVerifyCommit(commit) {
    return await gpgVerifyEntity('commit', commit);
}

async function gpgVerifyTag(tag) {
    return await gpgVerifyEntity('tag', tag)
}
async function gpgVerifyEntity(entity_type_name, entity) {
    const subCommand = createVerifySubCommand(entity_type_name)
        
    let gpg_status = '';
    const exec_options = ...; //ignoreResultCode, capture stdout etc.
    await core.exec('gpg2', [subCommand, '--raw', '--', entity], exec_options)
    return proceessGitGpgRawOutput(gpg_status);
}

function processGpgRawOutput(output) {
    for (const line in ...) {
        //1. try split of [GNUPG:] 
        //2. try split of GOODSIG/BADSIG etc.
        //3. try split of trust level
    }

    return new GPGVerifyResult(...)
}
